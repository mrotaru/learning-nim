** Hello World
#+BEGIN_SRC nim
  proc my_proc(name: string): string =
    return "Hello " & name
  
  echo my_proc("World!")
#+END_SRC

#+RESULTS:
: Hello World!

- simple statements: cannot contain other statements: assignment, proc calls, return
- complex statements: can contain other statements: if, when, for, while, etc
- complex statements must always be indented - but not simple statements
- expression: statement that results in a value
- expressions can contain indentation after operators, open paren, and after commas

#+BEGIN_SRC nim
  let long_variable_name_1, long_variable_name_2 = 100
  if long_variable_name_1 + long_variable_name_1 > 100 and
    long_variable_name_1 * long_variable_name_1 < 1000:
    echo "true"
  else:
    echo "false"
#+END_SRC

#+RESULTS:
: false

- parens create an expression, which can also be used in conditionals:
#+BEGIN_SRC nim
      let long_variable_name_1, long_variable_name_2 = 100
      if (
        long_variable_name_1 + long_variable_name_1 > 100 and
        long_variable_name_1 * long_variable_name_1 < 1000
      ):
        echo "true"
      else:
        echo "false"
#+END_SRC
#+RESULTS:
: false

** const vs let
#+BEGIN_SRC nim
  let x = 42
  # x = 100 # cannot re-assign "let"
  const c = "i can't be changed and must be known at compile time"
  echo x, c
#+END_SRC

#+RESULTS:
: 42i can't be changed and must be known at compile time

** if/else and when
   - well, not much to say here:
   #+BEGIN_SRC nim
     let x = 50
     if x < 25:
       echo "small"
     elif x > 25 and x < 75:
       echo "medium"
     else:
       echo "large"
   #+END_SRC

   #+RESULTS:
   : medium

   - ~when~ is something else though; it's compile-time thing, equivalent to ~#ifdef~ statements in ~C/C++~:
   #+BEGIN_SRC nim
     when system.hostOS == "linux":
       echo "THIS WILL ONLY RUN ON LINUX"
     else:
       echo "YOU SHOULD BE ASHAMED"
   #+END_SRC

   #+RESULTS:
   : YOU SHOULD BE ASHAMED
   
** case
   #+BEGIN_SRC nim
     from strutils import parseInt
     let n = 1
     case n
     of 0..5, 9, 10: echo "A"
     of 6..8: echo "B"
     else: echo "nope"
   #+END_SRC

   #+RESULTS:
   : A

** loops
   #+BEGIN_SRC nim
     echo "count up"
     for i in countup(1, 5):
       echo i

     echo "count up .."
     for i in 1..5:
       echo i

     echo "count up with while"
     var i = 1
     while i <= 5:
       echo i
       inc(i)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   count up
   1
   2
   3
   4
   5
   count up ..
   1
   2
   3
   4
   5
   count up with while
   1
   2
   3
   4
   5
   #+end_example

   #+BEGIN_SRC nim
     for i, x in ["a", "b", "c"].pairs:
       echo x, " at index ", i
   #+END_SRC

   #+RESULTS:
   : a at index 0
   : b at index 1
   : c at index 2

** scope and ~break~

   Scope is block-based; below will error, as ~x~ is accessed after the scope ends:
   #+BEGIN_SRC nim
     while false:
       var x = 42
       echo x
   #+END_SRC

   #+RESULTS:

   Named and anonymous block scopes:
   #+BEGIN_SRC nim
     block scope_1:
       var x = 1
       echo x
       block scope_2:
         var x = 2
         echo x
         block: # anonymous block
           var x = 3
           echo x
   #+END_SRC

   #+RESULTS:
   : 1
   : 2
   : 3

   ~break~ can exit loops - as one would expect:
   #+BEGIN_SRC nim 
     for i in 1..10:
       if i > 5: break
       echo i
   #+END_SRC

   #+RESULTS:
   : 1
   : 2
   : 3
   : 4
   : 5
   
   But ~break~ can also exit scope blocks:
   #+BEGIN_SRC nim
     block:
       echo "before"
       break
     echo "after"
   #+END_SRC

   #+RESULTS:
   : before

   When nested inside multiple "exitable" constructs (loops/blocks), the innermost one will be exited:
   #+BEGIN_SRC nim
     block:
       echo "foo"
       for i in 1..10:
         if i > 3: break
         echo i
         echo "bar"
   #+END_SRC

   #+RESULTS:
   : foo
   : 1
   : 2
   : 3
   : bar
   
   When ~break~ gets a block name, the block will be exited regardless of nesting:
   #+BEGIN_SRC nim
     block scope_1:
       echo "foo"
       for i in 1..10:
         if i > 3: break scope_1
         echo i
         echo "bar"
   #+END_SRC

   #+RESULTS:
   : foo
   : 1
   : 2
   : 3
   
   #+BEGIN_SRC nim
   #+END_SRC
   
   
** result, varargs
   - functions have an implicit ~result~ variable declared, which is used as return value:
   #+BEGIN_SRC nim
     proc sum(args: varargs[int]): int =
       for arg in args:
         result+=arg
    
     echo sum(0)
     echo sum(1,2,3)
   #+END_SRC

   #+RESULTS:
   : 0
   : 6
   
** parameters
   - params immutable by default
   #+BEGIN_SRC nim
     proc foo(x: int): void =
       x = 42 # Error: 'x' cannot be assigned to

     foo(0) 
   #+END_SRC

   #+RESULTS:
   
   - must declare param use ~var~ to mutate:
   #+BEGIN_SRC nim
     proc foo(x: var int): void =
       x = 42

     var x = 0
     foo(x)
     echo x
   #+END_SRC

   #+RESULTS:
   : 42

   - can also shadow params, by declaring same name as ~var~ inside the fn body:
   #+BEGIN_SRC nim
     proc foo(x: var int): void =
       var x = 42

     var x = 0
     foo(x)
     echo x
   #+END_SRC

   #+RESULTS:
   : 0
   
   - if a fn returns a value, normally it cannot be invoked without using the returned value:
   #+BEGIN_SRC nim
     proc foo(): int =
       return 42

     #foo() # Error: expression 'foo()' is of type 'int' and has to be used (or discarded)
     let x = foo() # fine - we're using the returned value, it's not "wasted"
     discard foo() # fine - we're explicitly discarding the returned value
   #+END_SRC

   - to allow a function's return value to be ignored implicitly, must use ~{.discardable}~ pragma:
   #+BEGIN_SRC nim
     proc foo(): int {.discardable.} =
       return 42

     foo() # fine
   #+END_SRC

   #+RESULTS:
   
   #+BEGIN_SRC nim
   #+END_SRC
